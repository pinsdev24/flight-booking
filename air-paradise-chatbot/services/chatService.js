const { getLLMResponse } = require('./llmService');
const { executeQuery } = require('./databaseService');
const { validateSqlQuery } = require('../utils/sqlValidator');
const { generateBookingReference } = require('../utils/helpers');

// In-memory store for booking sessions
const bookingSessions = new Map();

/**
 * Process a user's chat message and return appropriate response
 * @param {string} sessionId - Unique identifier for the user session
 * @param {string} message - User's message
 * @param {Array} history - Previous conversation history
 * @returns {Object} - { response, flights }
 */
async function processChat(sessionId, message, history) {
  try {
    // Sanitize user input
    const sanitizedMessage = sanitizeInput(message);
    
    // Get the current booking state if exists
    const bookingState = bookingSessions.get(sessionId) || { stage: 'initial' };
    
    // Get response from LLM
    const llmResponse = await getLLMResponse(sanitizedMessage, history, bookingState);
    
    // Extract SQL query if the response is in markdown code block format
    const extractedSql = extractSqlFromMarkdown(llmResponse);
    const processedResponse = extractedSql || llmResponse;
    
    // Check if response is an SQL query
    if (processedResponse.trim().toUpperCase().startsWith('SELECT')) {
      return await handleFlightSearch(processedResponse);
    } 
    // Check if we're in a booking flow
    else if (isBookingRequest(sanitizedMessage, llmResponse, bookingState)) {
      return await handleBookingFlow(sessionId, sanitizedMessage, llmResponse, bookingState);
    }
    // Regular conversational response
    else {
      return { 
        response: llmResponse,
        flights: [] 
      };
    }
  } catch (error) {
    console.error('Error processing chat:', error);
    return { 
      response: "Sorry, I couldn't process your request. Please try again.",
      flights: [] 
    };
  }
}

/**
 * Handle flight search by validating and executing SQL query
 * @param {string} sqlQuery - SQL query generated by LLM
 * @returns {Object} - { response, flights }
 */
async function handleFlightSearch(sqlQuery) {
  try {
    // Validate SQL query for security
    const validationResult = validateSqlQuery(sqlQuery);
    
    if (!validationResult.valid) {
      return { 
        response: "Sorry, I couldn't process your search request. Please try again with different criteria.",
        flights: [] 
      };
    }
    
    // Execute the validated query
    const flights = await executeQuery(validationResult.sanitizedQuery);
    
    if (flights.length === 0) {
      return { 
        response: "No flights found. Please adjust your search criteria.",
        flights: [] 
      };
    }
    
    // Format a user-friendly response
    const response = formatFlightResults(flights);
    
    return { response, flights: convertKeysToLowerCase(flights) };
  } catch (error) {
    console.error('Error handling flight search:', error);
    return { 
      response: "Sorry, there was an error processing your flight search. Please try again.",
      flights: [] 
    };
  }
}

/**
 * Format flight results into a readable message
 * @param {Array} flights - Array of flight objects
 * @returns {string} - Formatted message
 */
function formatFlightResults(flights) {
  const flightCount = flights.length;
  let response = `Found ${flightCount} flight${flightCount !== 1 ? 's' : ''}:\n\n`;
  
  flights.forEach((flight, index) => {
    // Format departure and arrival times from military time to standard format
    const depTime = formatTime(formatToMilitaryTime(flight.SCHEDULED_DEPARTURE));
    const arrTime = formatTime(formatToMilitaryTime(flight.SCHEDULED_ARRIVAL));
    
    // Get airline full name
    const airlineName = getAirlineName(flight.AIRLINE);
    
    response += `${index + 1}. ${flight.AIRLINE}${flight.FLIGHT_NUMBER} (${airlineName}) from ${flight.ORIGIN_AIRPORT} to ${flight.DESTINATION_AIRPORT}\n`;
    response += `   Date: ${flight.MONTH}/${flight.DAY}/${flight.YEAR}, Departure: ${depTime}, Arrival: ${arrTime}\n`;
    response += `   Price: $${flight.PREDICTED_PRICE}\n`;
    
    if (index < flights.length - 1) {
      response += '\n';
    }
  });
  
  response += '\nTo book a flight, please reply with "Book" followed by the airline and flight number (e.g., "Book DL123").';
  
  return response;
}

function convertKeysToLowerCase(obj) {
  if (Array.isArray(obj)) {
      return obj.map(item => convertKeysToLowerCase(item));
  } else if (obj !== null && typeof obj === 'object') {
      return Object.keys(obj).reduce((acc, key) => {
        let value = obj[key];
        // Convert SCHEDULED_DEPARTURE and SCHEDULED_ARRIVAL to military time
        if (key === 'SCHEDULED_DEPARTURE' || key === 'SCHEDULED_ARRIVAL') {
            value = formatToMilitaryTime(value);
        }
        acc[key.toLowerCase()] = convertKeysToLowerCase(value);
        return acc;
      }, {});
  }
  return obj;
}

/**
 * Format military time to standard time format
 * @param {string} militaryTime - Time in military format (e.g., '0800')
 * @returns {string} - Formatted time (e.g., '8:00 AM')
 */
function formatTime(militaryTime) {
  if (!militaryTime || militaryTime.length !== 4) {
    return 'Unknown';
  }
  
  const hours = parseInt(militaryTime.substring(0, 2));
  const minutes = militaryTime.substring(2);
  const period = hours >= 12 ? 'PM' : 'AM';
  const standardHours = hours % 12 || 12;
  
  return `${standardHours}:${minutes} ${period}`;
}

/**
 * Format numeric time to HH:mm format
 * @param {number} time - Numeric time (e.g., 515)
 * @returns {string} - Formatted time (e.g., "05:15")
 */
function formatToMilitaryTime(time) {
  // Convert numeric time (e.g., 515) to HH:mm format (e.g., "05:15")
  const hours = Math.floor(time / 100);
  const minutes = time % 100;
  return `${hours.toString().padStart(2, '0')}${minutes.toString().padStart(2, '0')}`;
}

/**
 * Get airline name from airline code
 * @param {string} airlineCode - Airline code (e.g., 'WN', 'DL')
 * @returns {string} - Airline name
 */
function getAirlineName(airlineCode) {
  const airlines = {
    'WN': 'Southwest Airlines',
    'DL': 'Delta Air Lines',
    'AA': 'American Airlines',
    'OO': 'SkyWest Airlines',
    'EV': 'ExpressJet',
    'UA': 'United Airlines',
    'MQ': 'Envoy Air',
    'B6': 'JetBlue Airways',
    'US': 'US Airways',
    'AS': 'Alaska Airlines',
    'NK': 'Spirit Airlines',
    'F9': 'Frontier Airlines',
    'HA': 'Hawaiian Airlines',
    'VX': 'Virgin America'
  };

  return airlines[airlineCode] || airlineCode;
}

/**
 * Determine if the message is part of a booking flow
 * @param {string} message - User's message
 * @param {string} llmResponse - LLM's response
 * @param {Object} bookingState - Current booking state
 * @returns {boolean}
 */
function isBookingRequest(message, llmResponse, bookingState) {
  // Check if already in a booking flow
  if (bookingState.stage !== 'initial') {
    return true;
  }
  
  // Check for new booking request
  const bookingKeywords = ['book', 'reserve', 'purchase'];
  return bookingKeywords.some(keyword => 
    message.toLowerCase().includes(keyword)) ||
    llmResponse.toLowerCase().includes('provide your full name') ||
    llmResponse.toLowerCase().includes('passport number');
}

/**
 * Handle the booking flow based on current state
 * @param {string} sessionId - Unique identifier for the user session
 * @param {string} message - User's message
 * @param {string} llmResponse - LLM's response
 * @param {Object} bookingState - Current booking state
 * @returns {Object} - { response, flights }
 */
async function handleBookingFlow(sessionId, message, llmResponse, bookingState) {
  let updatedState = { ...bookingState };
  let response = llmResponse;

  // Determine the stage based on LLM response or existing state
  if (bookingState.stage === 'initial') {
    // Starting a new booking
    if (llmResponse.toLowerCase().includes('provide your full name')) {
      updatedState.stage = 'awaiting_name';
      
      // Try to extract flight details from the message
      const flightMatch = message.match(/book\s+([A-Z]{2})(\d+)/i);
      if (flightMatch) {
        updatedState.airline = flightMatch[1].toUpperCase();
        updatedState.flightNumber = flightMatch[2];
      }
    }
  } 
  else if (bookingState.stage === 'awaiting_name') {
    // Store name and passport if provided
    const nameParts = message.split(',');
    if (nameParts.length >= 1) {
      updatedState.userName = nameParts[0].trim();
      
      if (nameParts.length >= 2) {
        updatedState.passportNumber = nameParts[1].trim();
      }
      
      updatedState.stage = 'awaiting_payment';
    }
  } 
  else if (bookingState.stage === 'awaiting_payment' && 
           message.match(/\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}/)) {
    // Payment info provided, complete booking
    try {
      // Find flight_id based on stored airline and flight number
      let flightId = null;
      if (updatedState.airline && updatedState.flightNumber) {
        const query = `SELECT id FROM flights 
                       WHERE airline = $1 AND flight_number = $2`;
        const flights = await executeQuery(query, [updatedState.airline, updatedState.flightNumber]);
        
        if (flights && flights.length > 0) {
          flightId = flights[0].id;
        }
      }
      
      // Generate a booking reference
      const bookingReference = generateBookingReference();
      
      // Insert into bookings table
      if (flightId && updatedState.userName && updatedState.passportNumber) {
        const insertQuery = `INSERT INTO bookings 
                             (flight_id, user_name, passport_number, booking_reference) 
                             VALUES ($1, $2, $3, $4)`;
        await executeQuery(insertQuery, [
          flightId, 
          updatedState.userName, 
          updatedState.passportNumber,
          bookingReference
        ]);
        
        response = `Booking confirmed! Your booking reference is ${bookingReference}. Thank you for choosing AIR PARADISE!`;
      } else {
        response = "Sorry, I couldn't process your booking due to missing information. Please try again.";
      }
      
      // Clear booking state
      bookingSessions.delete(sessionId);
    } catch (error) {
      console.error('Error completing booking:', error);
      response = "Sorry, there was an error processing your booking. Please try again.";
    }
  }
  
  // Update the booking state in memory
  if (updatedState.stage !== 'initial') {
    bookingSessions.set(sessionId, updatedState);
  }
  
  return {
    response,
    flights: []
  };
}

/**
 * Sanitize user input to prevent injection
 * @param {string} input - User input
 * @returns {string} - Sanitized input
 */
function sanitizeInput(input) {
  // Basic sanitization
  return input
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/'/g, '&#39;')
    .replace(/"/g, '&quot;');
}

/**
 * Extract SQL query from markdown code block
 * @param {string} response - LLM response potentially containing SQL in markdown
 * @returns {string|null} - Extracted SQL or null if no SQL found
 */
function extractSqlFromMarkdown(response) {
  // Match SQL inside markdown code blocks (```sql ... ``` or ``` ... ```) 
  const sqlCodeBlockRegex = /```(?:sql)?\s*([\s\S]*?)\s*```/i;
  const match = response.match(sqlCodeBlockRegex);
  
  if (match && match[1]) {
    return match[1].trim();
  }
  
  return null;
}

module.exports = {
  processChat
};
